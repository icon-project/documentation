---
title: "Writing SCORE"
---

This document presents how to write a SCORE, smart contract of the ICON network.
Through this document, you will learn from setting the workspace to deploying a SCORE.

Technically speaking, SCORE is the platform for ICON's smart contract. But it is also used to refer to the ICON's smart contract itself.


## Intended Audience

The intended audience is the developers who have basic Python programming knowledge. 

## Purpose

After reading this document, you will understand the structure of SCORE and learn the basic syntax of writing SCORE.

## Prerequisite

* [SCORE Overview](doc:score-overview) 
* [Token & Crowdsale](doc:token-crowdsale)
* [T-Bears CLI Commands](doc:how-to-use-t-bears) 

## Creating a Workspace

SCORE is written in Python programming language, so you can use any Python programming tools, as long as the required files, as listed below, are included in the SCORE project. These files are all plain text.
* \_\_init\_\_.py: This file makes Python treat the directory containing the file as a package.
* project.py: The main module file of the SCORE to be executed at the top level. This file name should be given in the `package.json`.
* package.json: This file contains the basic information about the SCORE.

Using T-Bears, you can create a workspace for writing SCORE. T-Bears creates the above-mentioned template files for SCORE and other configuration files for the development environments. You can refer to the T-Bears guide for the details.

T-Bears `init` command will create a SCORE project.
```bash
$ tbears init [project_name] [main_class_name]
$ tbears init hello_world HelloWorld
```
In the `hello_world` folder, SCORE template is created. 
```bash
$ ls -lF
total 4
drwxr-xr-x  6 edward  staff   192  4  4 10:24 hello_world/

$ ls -lF hello_world/
total 16
-rw-r--r--  1 edward  staff    0  4  4 10:20 __init__.py
-rw-r--r--  1 edward  staff  420  4  4 10:20 hello_world.py
-rw-r--r--  1 edward  staff   90  4  4 10:20 package.json
drwxr-xr-x  4 edward  staff  128  4  4 10:23 tests/
```

## Structure of SCORE

SCORE is a collection of codes written in Python. There should be a main class which has member variables and methods. The main class name should be specified in the `package.json` as the value of `main_score` field so that ICON nodes determine which class should be loaded and executed as an entry point. 
The main class must implement three methods (`__init__`, `on_install`, `on_update`) that are invoked on loading, installing, and updating SCORE respectively. In addition, the main class should have more than one external methods which are supposed to be invoked by transactions from EOA or other Smart Contracts. Transactions will result in the internal state update. 
The main class has member variables to store its states, and those variables should be incorporated with the state database, which will be explained later with VarDB, DictDB, and ArrayDB.

The following is the content of the main class which we have just generated by T-Bears `init` command.

```python
from iconservice import *

TAG = 'HelloWorld'

class HelloWorld(IconScoreBase):

    def __init__(self, db: IconScoreDatabase) -> None:
        super().__init__(db)

    def on_install(self) -> None:
        super().on_install()

    def on_update(self) -> None:
        super().on_update()

    @external(readonly=True)
    def hello(self) -> str:
        Logger.debug(f'Hello, world!', TAG)
        return "Hello"
```


## IconScoreBase

Every main class of SCORE should be inherited from `IconScoreBase`. If the main class is not derived from `IconScoreBase`, it cannot be deployed.

The main class should have 3 methods, `__init__`, `on_install` and `on_update`.


### \_\_init\_\_

`__init__` is the constructor for the class. This method gets called whenever the class object is instantiated.

Member variables can be declared here, however, declaring member variables which are not managed by state DB is prohibited. In other words, all member variables must be stored in the state database to keep the values non-volatile during the executions of the smart contract. 

Here's an example of declaring member variables as state data.

```python
def __init__(self, db: IconScoreDatabase) -> None:
    # Parent’s __init__ method must be called as well
    super().__init__(db)

    self._total_supply = VarDB('total_supply', db, value_type=int)
    self._decimals = VarDB('decimals', db, value_type=int)
    self._balances = DictDB('balances', db, value_type=int)
```

### on\_install

This method is called when the smart contract is deployed for the first time, and will not be called again on contract update or deletion afterward. This is the place where you initialize the state database.

### on\_update
This method is called when the smart contract is updated.

### Built-in Properties

These are member variables supported by `IconScoreBase`, whose values are set by the ICON platform to deliver necessary information to the SCORE. Therefore, they are read-only variables and do not allow to be modified by the contract.

* `msg`: Holds information of the account who called the SCORE method.
    - `msg.sender`: Address of the account who called this method. If it is another contact that called this method, `msg.sender` points to the caller contract's address.
    - `msg.value`: Amount of ICX that the sender attempts to transfer to the SCORE.
* `tx`: Transaction information
    - `tx.origin`: The account who created the transaction.
    - `tx.index`: Transaction index.
    - `tx.hash`: Transaction hash.
    - `tx.timestamp`: Transaction creation time.
    - `tx.nonce`: (optional) an arbitrary number set by the sender.
* `icx`: An object used to transfer ICX coins
    - This object provides two methods, see [Transferring ICX](#section-transferring-icx) for details.
* `db`: An instance used to access the state DB
* `address`: Address of the SCORE
* `owner`: Address of the account who deployed the contract
* `block_height`: Current block height
* `now`: Wrapping method of `block.timestamp`.


## Implementing SCORE External Methods

Users can implement methods which are supposed to be invoked from outside the blockchain.
These methods can be decorated with `@external` and/or `@payable`.
Additionally, users can declare methods decorated with `@eventlog` which can be used to leave custom event logs in the TxResult.

### External decorator (@external)

Methods decorated with `@external` can be called from outside the contract. These methods are registered on the external API list and users can query the API list through `icx_getScoreApi` JSON RPC call.

Any attempt to call a non-external method from outside the contract will fail.

If a method is decorated with a  `readonly` parameter, i.e., `@external(readonly=True)`, the method will have read-only access to the state database.

If a read-only external method is also decorated with `@payable`, the method call will fail.

Duplicate declaration of `@external` will raise an exception on class loading time.

Possible data types for external method parameters are Python primitive types (`int`, `str`, `bytes`, `bool`) and `Address` (newly defined type for SCORE codes).
`list`, `dict` and `None` types are not supported as method parameters.
Method parameters can have default values.


### Payable decorator (@payable)

Only the methods with `@payable` decorator are permitted to receive incoming ICX coins.
Transferring zero ICX is acceptable if it is decorated with `@payable`.
If ICX coins (`self.msg.value`) are passed to a non-payable method, that transaction will fail.


### Eventlog decorator (@eventlog)

Methods decorated with `@eventlog` can be called within SCORE codes during the execution of a transaction to include custom event logs in its TxResult as `eventlogs`.
It is recommended to declare a method without an implementation body. Even if the method has an implementation body, it does not be executed. 
When declaring a method, Python type hints must be specified. Without type hinting, SCORE loading will fail.

If an `indexed` parameter is set in the decorator, the designated number of parameters in the order of declaration will be indexed and included in the Bloom filter.
At most 3 parameters can be indexed, and the index cannot exceed the number of parameters, otherwise, an error will be raised.
Indexed parameters and non-indexed parameters are separately stored in TxResult.

Example)
```python
# Declaration
@eventlog
def FundTransfer1(self, _backer: Address, _amount: int, _isContribution: bool): pass

@eventlog(indexed=1) # The first parameter (_backer) will be indexed
def FundTransfer2(self, _backer: Address, _amount: int, _isContribution: bool): pass

# Execution
self.FundTransfer1(self.msg.sender, amount, True)
self.FundTransfer2(self.msg.sender, amount, True)
```

### fallback

`fallback` is a special method that is executed whenever the smart contract receives plain ICX coins without data.

```python
@payable
def fallback(self):
    """
    Called when anyone sends ICX to the SCORE.
    """
    if something_wrong:
        revert('something wrong')
```

If `fallback` method is not decorated with `@payable`, the ICX coin transfers to the contract will fail even for the zero ICX transfer.

`fallback` method cannot be decorated with `@external` (i.e., `fallback` method is not allowed to be called explicitly by other contract or user).
An exception will be raised and the SCORE will be rejected during its deployment if `fallback` has `@external` decorator.

If you query the SCORE API list, you will receive `fallback` method only if it is decorated with `@payable` decorator.


## Storing State Data

The state of SCORE should be stored in the state database in the blockchain. The state of SCORE simply means the values of member variables in the smart contract which are declared as VarDB, DictDB, and ArrayDB. The state of SCORE is changed only by the execution of transactions. All nodes execute transactions and change the state of the smart contract in their own state database independently. To be confirmed, the changed state should be agreed between the ⅔ of nodes after each execution of transactions, and this process is called consensus in the blockchain.

In general, the state database is a key-value database, and can be accessed using VarDB, DictDB and ArrayDB classes.

VarDB, DictDB, and ArrayDB are utility classes wrapping the state database.
A `key` can be numbers or characters, and `value_type` can be `int`, `str`, `bytes` and `Address`.
If the `key` does not exist, the wrapping classes return the *zero value* of `value_type`, which is 0 for `int`, "" for `str`, and None for `bytes` or `Address`.

VarDB can be used to store simple key-value state, and DictDB behaves more like Python `dict`.
DictDB does not maintain order, whereas ArrayDB, which supports length and iterator, maintains order.

**VarDB(‘key’, ‘target db’, ‘return type’)**

Example) Setting a value "icon" for the key "name" on the state DB:

```python
VarDB('name', db, value_type=str).set('icon')
```

Example) Getting value by the key "name":

```python
name = VarDB('name', db, value_type=str).get()
print(name) ## 'icon'
```

**DictDB(‘key’, ‘target db’, ‘return type’, ‘dict depth (default is 1)’)**

Example 1) One-depth dict

```python
test_dict1 = DictDB('test_dict1', db, value_type=int)
test_dict1['key'] = 1 ## set
print(test_dict1['key']) ## get 1

print(test_dict1['nonexistence_key']) # prints 0 (key does not exist and value_type=int)
```

Example 2) Two-depth dict

```python
test_dict2 = DictDB('test_dict2', db, value_type=str, depth=2)
test_dict2['key1']['key2'] = 'a' ## set
print(test_dict2['key1']['key2']) ## get 'a'

print(test_dict2['key1']['nonexistent_key']) # prints "" (key does not exist and value_type=str)
```

If the depth is 2 or greater, `test_dictN['key']` returns new DictDB with the depth N-1.
Attempting to set a value to the wrong depth in the DictDB will raise an exception.

Example 3)
```python
test_dict3 = DictDB('test_dict3', db, value_type=int, depth=3)
test_dict3['key1']['key2']['key3'] = 1 ## ok
test_dict3['key1']['key2'] = 1 ## raise mismatch exception

test_dict2 = test_dict3['key']['key2']
test_dict2['key1'] = 1 ## ok
```

**ArrayDB(‘key’, ‘target db’, ‘return type’)**

ArrayDB supports one-dimensional array only.
ArrayDB supports `put`, `get` and `pop` operations, i.e., the data can be accessed in a stack-like fashion. It does not support `insert` or `delete` operation (adding or removing elements in the middle of the array).

```python
test_array = ArrayDB('test_array', db, value_type=int)
test_array.put(0)
test_array.put(1)
test_array.put(2)
test_array.put(3)
print(len(test_array)) ## prints 4
print(test_array.pop()) ## prints 3
test_array[0] = 0 ## ok
# test_array[100] = 1 ## error
for e in test_array: ## ok
    print(e)
print(test_array[-1]) ## ok
# print(test_array[-100]) ## error
```

#### Cautions about VarDB, DictDB and ArrayDB

The state should be stored in persistent storage (state database). Variables which reside in memory are volatile and will be reset when the nodes are restarted. Thus SCORE developers need to use the wrapping classes of the state database, VarDB, ArrayDB, and DictDB, to store the state permanently. Please be careful that you use these classes correctly, otherwise, you may have unexpected results.

Example)
```python
varDB = VarDB(...)
varDB.set(100)       # right
varDB = 100          # wrong

arrayDB = ArrayDB(...)
arrayDB[0] = 100     # right
arrayDB = 100        # wrong

dictDB = DictDB(...)
dictDB['key0'] = 100 # right
dictDB = 100         # wrong
```

## Invoking Other SCORE Methods

### InterfaceScore
`InterfaceScore` is an interface class that is used to invoke other SCORE’s method.
This interface should be used instead of the legacy `call` method. Usage syntax is as follows.

```python
class TokenInterface(InterfaceScore):
    @interface
    def transfer(self, _to: Address, _value: int, _data: bytes=None):
        pass
```

If another SCORE has the method whose signature is the same as defined here with `@interface` decorator, the method can be invoked via `InterfaceScore` class object.
Like `@eventlog` decorator, it is recommended to declare a method without an implementation body.
If there is an implementation body, it will be simply ignored.

You need to get an `InterfaceScore` object by using `IconScoreBase`’s built-in API,
`create_interface_score('score address', 'interface class')`.
Using the object, you can invoke other SCORE’s external method as if it is a local method call.

Example)

```python
# excerpt from Crowdsale SCORE
@payable
def fallback(self):
    ...
    data = b'called from Crowdsale'

    # gets an interface object of the token SCORE
    token_score = self.create_interface_score(self._addr_token_score.get(), TokenInterface)
    # transfers tokens to the contributor as a reward
    token_score.transfer(self.msg.sender, value, data)
    ...
```

## Transferring ICX

Users can transfer ICX coins using `icx` object and it offers 2 methods, `send` and `transfer`.

* `icx.transfer(addr_to: Aaddress, amount: int) -> None`
   - Transfers designated amount of ICX coins to `addr_to`.
   - If an exception occurs during execution, the exception will be escalated to the user.

* `icx.send(addr_to: Address, amount: int) -> bool`
   - Sends the designated amount of ICX coins to `addr_to`.
   - Basic behavior is the same as `icx.transfer`, but the raised exception will be caught inside the method.
   - Returns `True` when the coin transfer succeeded, `False` when it failed.


## Type Hints

Type hinting is highly recommended for the input parameters and return value.
When clients want to query the list of SCORE's API, the API specification is generated based on its type hints.
If type hints are not given to external methods, just method names will return.

```python
@external(readonly=True)
def func1(arg1: int, arg2: str) -> int:
    return 100
```
Possible data types for method parameters are `int`, `str`, `bytes`, `bool` and `Address`.
`list` and `dict` type parameters are not supported for method parameters.
Return types can be `int`, `str`, `bytes`, `bool`, `Address`, `list` and `dict`.


## Exception Handling

When you handle exceptions in your contract, it is recommended to use `revert` function
rather than using an `IconScoreException`.


## Deploying SCOREs
We assume that you already have installed T-Bears. If you have not yet installed it, please read [SCORE Quickstart](doc:score-quickstart) or [T-Bears Installation](doc:tbears-installation) first.

### package.json

Before deploying a SCORE, the required files should be packaged into a zip file. In the zip file, SCORE metadata should be included as well as the smart contract source code itself.
The metadata file, `package.json`, contains a version, main module name, and main class.

Here is an example of `package.json` file.

```json
{
    "version": "0.0.1",
    "main_module": "hello_world",
    "main_score": "HelloWorld"
}
```

The SCORE execution runtime will find `main_score` class in the `main_module`.py to load and execute it on the ICON network.

If you want to make `main_module` point to a submodule, you can specify the module name as below.
```json
{
    "version": "0.0.1",
    "main_module": "sub_module.hello_world",
    "main_score": "HelloWorld"
}
```

### Deploying SCOREs with T-Bears

Here is an example of deploying a SCORE onto the local T-Bears emulator.
If you want to deploy on Mainnet or Testnet, you need to edit `uri` and `keyStore` fields in `tbears_cli_config.json`.

The [SampleToken](token-crowdsale) is used in this example.

#### Deploy SampleToken on Local T-Bears Emulator

1. Generate T-Bears CLI configuration.
    ```console
    $ tbears genconf
    ```

2. Start T-Bears emulator on the local environment.
    ```console
    $ tbears start
    ```

3. Open `tbears_cli_config.json` and edit it as follows.
    Parameters for `on_install()` method (`_initialSupply` and `_decimals`) should be set under `scoreParams` field.
    ```json
    {
        "uri": "http://127.0.0.1:9000/api/v3",
        "nid": "0x3",
        "keyStore": null,
        "from": "hxe7af5fcfd8dfc67530a01a0e403882687528dfcb",
        "to": "cx0000000000000000000000000000000000000000",
        "deploy": {
            "stepLimit": "0x10000000",
            "mode": "install",
            "scoreParams": {
                "_initialSupply": "0x3e8",
                "_decimals": "0x12"
            }
        },
        "txresult": {},
        "transfer": {
            "stepLimit": "0xf4240"
        }
    }
    ```

4. Deploy the SampleToken
    Using `deploy` command in T-Bears, you can deploy the sample_token project with configuration `tbears_cli_config.json`.
    T-Bears makes a zip file from the sample_token directory on the fly and deploys it to the local server.
    ```console
    $ tbears deploy sample_token -c tbears_cli_config.json
    Send deploy request successfully.
    If you want to check SCORE deployed successfully, execute txresult command
    transaction hash: 0xea834af48150189b4021b9a161d4c0aff3d983ccc47ddc189bac50f55bf580b7
    ```

5. Get transaction result by transaction hash.
    You can check the result of deployment by querying the transaction hash.
    ```console
    $ tbears txresult 0xea834af48150189b4021b9a161d4c0aff3d983ccc47ddc189bac50f55bf580b7
    ```
    Here's the result of the transaction. You can find the `scoreAddress`, which is the address of this deployed SCORE, and that address will be used for invoking external methods of SampleToken later.
    ```consolie
    Transaction result: {
        "jsonrpc": "2.0",
        "result": {
            "txHash": "0xea834af48150189b4021b9a161d4c0aff3d983ccc47ddc189bac50f55bf580b7",
            "blockHeight": "0xbe",
            "blockHash": "0xdc85bccb32109da6cfe5bb5308121ce68a1494c499d9dd8c724a0bd7397d0729",
            "txIndex": "0x0",
            "to": "cx0000000000000000000000000000000000000000",
            "scoreAddress": "cx0841205d73b93aec1062877d8d4d5ea54c6665bb",
            "stepUsed": "0x2cc8f10",
            "stepPrice": "0x0",
            "cumulativeStepUsed": "0x2cc8f10",
            "eventLogs": [],
            "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "status": "0x1"
        },
        "id": 1
    }
    ```

## Invoking SCORE methods

### Invoking read-only methods

The SCORE methods can be executed by calling [JSON RPC APIs](icon-json-rpc-v3) to ICON nodes.
You need to generate a JSON file which contains information about the calling method and its parameters.

`icx_call` JSON-RPC API will be used to invoke a read-only method of SCORE.

#### Getting total supply

Make a JSON file for calling `totalSupply` in SampleToken as follows.

```json
# totalsupply.json
{
    "jsonrpc": "2.0",
    "method": "icx_call",
    "id": 1,
    "params": {
        "to": "cx0841205d73b93aec1062877d8d4d5ea54c6665bb",
        "dataType": "call",
        "data": {
            "method": "totalSupply"
        }
    }
}
```

You can use T-Bears `call` command to send the request. `tbears call` commands implements the `icx_call` JSON-RPC protocol.

```console
$ tbears call totalsupply.json
response : {
    "jsonrpc": "2.0",
    "result": "0x3635c9adc5dea00000",
    "id": 1
}
```

#### Getting balance of specific address

Make another JSON file for calling `balanceOf` in SampleToken.
In this case, you need to specify `_owner` parameter for the `balanceOf` method.

```json
# balanceof.json
{
    "jsonrpc": "2.0",
    "method": "icx_call",
    "id": 1,
    "params": {
        "to": "cx0841205d73b93aec1062877d8d4d5ea54c6665bb",
        "dataType": "call",
        "data": {
            "method": "balanceOf",
            "params": {
                "_owner": "hxef73db5d0ad02eb1fadb37d0041be96bfa56d4e6"
            }
        }
    }
}
```

Again, you can use T-Bears `call` command to send the request.

```console
$ tbears call balanceof.json
response : {
    "jsonrpc": "2.0",
    "result": "0x0",
    "id": 1
}
```

The result of calling `balanceOf` is 0, that means the balance of address `hxef73db5d0ad02eb1fadb37d0041be96bfa56d4e6` is 0.


### Invoking writable methods

The JSON RPC method, `icx_sendTransaction`, should be used for invoking writable SCORE methods.

The writable methods can change the state of the smart contract. So the signature should be presented in the JSON RPC request to prove the transaction was originated by the `from` account.  The `to` is the address of the smart contract.

The following example request is transferring 1 token to `hxef73db5d0ad02eb1fadb37d0041be96bfa56d4e6` from `hxe7af5fcfd8dfc67530a01a0e403882687528dfcb`.

```json
# sendtoken.json
{
    "jsonrpc": "2.0",
    "method": "icx_sendTransaction",
    "params": {
        "version": "0x3",
        "from": "hxe7af5fcfd8dfc67530a01a0e403882687528dfcb",
        "value": "0x0",
        "stepLimit": "0x3000000",
        "timestamp": "0x573117f1d6568",
        "nid": "0x3",
        "nonce": "0x1",
        "to": "cx0841205d73b93aec1062877d8d4d5ea54c6665bb",
        "signature": "",
        "dataType": "call",
        "data": {
            "method": "transfer",
            "params": {
                "_to": "hxef73db5d0ad02eb1fadb37d0041be96bfa56d4e6",
                "_value": "0xde0b6b3a7640000"
            }
        }
    },
    "id": 1
}
```

You can use T-Bears `sendtx` command for calling writable SCORE methods.
You need to input an appropriate password of the keystore file, `keystore_test1`.

```console
$ tbears sendtx sendtoken.json -k keystore_test1
Input your keystore password: 
Send transaction request successfully.
transaction hash: 0x41bf7b9ada89eb938ee4e36fce02ec86b3e68c1ceefd61decfe1e3dcc7df43a5
```

Getting the transaction hash itself in the response of sending transaction does not mean the successful execution of the transaction.
You need to check the actual result of the transaction by calling `icx_getTransactionResult` JSON RPC API.
With T-Bears, you can use `txresult` command.

```console
$ tbears txresult 0x41bf7b9ada89eb938ee4e36fce02ec86b3e68c1ceefd61decfe1e3dcc7df43a5
Transaction result: {
    "jsonrpc": "2.0",
    "result": {
        "txHash": "0x41bf7b9ada89eb938ee4e36fce02ec86b3e68c1ceefd61decfe1e3dcc7df43a5",
        "blockHeight": "0x4c",
        "blockHash": "0x7f53737f9ead2a04afe72d90bef072d49fa74c1f37b4029801e787aa15d37895",
        "txIndex": "0x0",
        "to": "cx0841205d73b93aec1062877d8d4d5ea54c6665bb",
        "stepUsed": "0xfdb2e",
        "stepPrice": "0x0",
        "cumulativeStepUsed": "0xfdb2e",
        "eventLogs": [
            {
                "scoreAddress": "cx0841205d73b93aec1062877d8d4d5ea54c6665bb",
                "indexed": [
                    "Transfer(Address,Address,int,bytes)",
                    "hxe7af5fcfd8dfc67530a01a0e403882687528dfcb",
                    "hxef73db5d0ad02eb1fadb37d0041be96bfa56d4e6",
                    "0xde0b6b3a7640000"
                ],
                "data": [
                    "0x4e6f6e65"
                ]
            }
        ],
        "logsBloom": "0x00000000000000100000002000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000100000040000000000000000200000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000100000002000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000080000000000000000000000000000000000000000",
        "status": "0x1"
    },
    "id": 1
}
```

The `status` field in the result indicates whether the transaction was succeeded or not (0x1 on success, 0x0 on failure).


## API Reference
[iconservice API references](doc:iconservice-api-references) 
